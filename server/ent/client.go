// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"edumeet/ent/migrate"

	"edumeet/ent/badge"
	"edumeet/ent/document"
	"edumeet/ent/event"
	"edumeet/ent/eventdocument"
	"edumeet/ent/message"
	"edumeet/ent/participant"
	"edumeet/ent/physicalevent"
	"edumeet/ent/remoteevent"
	"edumeet/ent/reporting"
	"edumeet/ent/subject"
	"edumeet/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Badge is the client for interacting with the Badge builders.
	Badge *BadgeClient
	// Document is the client for interacting with the Document builders.
	Document *DocumentClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventDocument is the client for interacting with the EventDocument builders.
	EventDocument *EventDocumentClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// Participant is the client for interacting with the Participant builders.
	Participant *ParticipantClient
	// PhysicalEvent is the client for interacting with the PhysicalEvent builders.
	PhysicalEvent *PhysicalEventClient
	// RemoteEvent is the client for interacting with the RemoteEvent builders.
	RemoteEvent *RemoteEventClient
	// Reporting is the client for interacting with the Reporting builders.
	Reporting *ReportingClient
	// Subject is the client for interacting with the Subject builders.
	Subject *SubjectClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Badge = NewBadgeClient(c.config)
	c.Document = NewDocumentClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventDocument = NewEventDocumentClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.Participant = NewParticipantClient(c.config)
	c.PhysicalEvent = NewPhysicalEventClient(c.config)
	c.RemoteEvent = NewRemoteEventClient(c.config)
	c.Reporting = NewReportingClient(c.config)
	c.Subject = NewSubjectClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Badge:         NewBadgeClient(cfg),
		Document:      NewDocumentClient(cfg),
		Event:         NewEventClient(cfg),
		EventDocument: NewEventDocumentClient(cfg),
		Message:       NewMessageClient(cfg),
		Participant:   NewParticipantClient(cfg),
		PhysicalEvent: NewPhysicalEventClient(cfg),
		RemoteEvent:   NewRemoteEventClient(cfg),
		Reporting:     NewReportingClient(cfg),
		Subject:       NewSubjectClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Badge:         NewBadgeClient(cfg),
		Document:      NewDocumentClient(cfg),
		Event:         NewEventClient(cfg),
		EventDocument: NewEventDocumentClient(cfg),
		Message:       NewMessageClient(cfg),
		Participant:   NewParticipantClient(cfg),
		PhysicalEvent: NewPhysicalEventClient(cfg),
		RemoteEvent:   NewRemoteEventClient(cfg),
		Reporting:     NewReportingClient(cfg),
		Subject:       NewSubjectClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Badge.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Badge, c.Document, c.Event, c.EventDocument, c.Message, c.Participant,
		c.PhysicalEvent, c.RemoteEvent, c.Reporting, c.Subject, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Badge, c.Document, c.Event, c.EventDocument, c.Message, c.Participant,
		c.PhysicalEvent, c.RemoteEvent, c.Reporting, c.Subject, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BadgeMutation:
		return c.Badge.mutate(ctx, m)
	case *DocumentMutation:
		return c.Document.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventDocumentMutation:
		return c.EventDocument.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *ParticipantMutation:
		return c.Participant.mutate(ctx, m)
	case *PhysicalEventMutation:
		return c.PhysicalEvent.mutate(ctx, m)
	case *RemoteEventMutation:
		return c.RemoteEvent.mutate(ctx, m)
	case *ReportingMutation:
		return c.Reporting.mutate(ctx, m)
	case *SubjectMutation:
		return c.Subject.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BadgeClient is a client for the Badge schema.
type BadgeClient struct {
	config
}

// NewBadgeClient returns a client for the Badge from the given config.
func NewBadgeClient(c config) *BadgeClient {
	return &BadgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `badge.Hooks(f(g(h())))`.
func (c *BadgeClient) Use(hooks ...Hook) {
	c.hooks.Badge = append(c.hooks.Badge, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `badge.Intercept(f(g(h())))`.
func (c *BadgeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Badge = append(c.inters.Badge, interceptors...)
}

// Create returns a builder for creating a Badge entity.
func (c *BadgeClient) Create() *BadgeCreate {
	mutation := newBadgeMutation(c.config, OpCreate)
	return &BadgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Badge entities.
func (c *BadgeClient) CreateBulk(builders ...*BadgeCreate) *BadgeCreateBulk {
	return &BadgeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BadgeClient) MapCreateBulk(slice any, setFunc func(*BadgeCreate, int)) *BadgeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BadgeCreateBulk{err: fmt.Errorf("calling to BadgeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BadgeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BadgeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Badge.
func (c *BadgeClient) Update() *BadgeUpdate {
	mutation := newBadgeMutation(c.config, OpUpdate)
	return &BadgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BadgeClient) UpdateOne(b *Badge) *BadgeUpdateOne {
	mutation := newBadgeMutation(c.config, OpUpdateOne, withBadge(b))
	return &BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BadgeClient) UpdateOneID(id string) *BadgeUpdateOne {
	mutation := newBadgeMutation(c.config, OpUpdateOne, withBadgeID(id))
	return &BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Badge.
func (c *BadgeClient) Delete() *BadgeDelete {
	mutation := newBadgeMutation(c.config, OpDelete)
	return &BadgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BadgeClient) DeleteOne(b *Badge) *BadgeDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BadgeClient) DeleteOneID(id string) *BadgeDeleteOne {
	builder := c.Delete().Where(badge.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BadgeDeleteOne{builder}
}

// Query returns a query builder for Badge.
func (c *BadgeClient) Query() *BadgeQuery {
	return &BadgeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBadge},
		inters: c.Interceptors(),
	}
}

// Get returns a Badge entity by its id.
func (c *BadgeClient) Get(ctx context.Context, id string) (*Badge, error) {
	return c.Query().Where(badge.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BadgeClient) GetX(ctx context.Context, id string) *Badge {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Badge.
func (c *BadgeClient) QueryUsers(b *Badge) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(badge.Table, badge.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, badge.UsersTable, badge.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BadgeClient) Hooks() []Hook {
	return c.hooks.Badge
}

// Interceptors returns the client interceptors.
func (c *BadgeClient) Interceptors() []Interceptor {
	return c.inters.Badge
}

func (c *BadgeClient) mutate(ctx context.Context, m *BadgeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BadgeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BadgeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BadgeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Badge mutation op: %q", m.Op())
	}
}

// DocumentClient is a client for the Document schema.
type DocumentClient struct {
	config
}

// NewDocumentClient returns a client for the Document from the given config.
func NewDocumentClient(c config) *DocumentClient {
	return &DocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `document.Hooks(f(g(h())))`.
func (c *DocumentClient) Use(hooks ...Hook) {
	c.hooks.Document = append(c.hooks.Document, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `document.Intercept(f(g(h())))`.
func (c *DocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Document = append(c.inters.Document, interceptors...)
}

// Create returns a builder for creating a Document entity.
func (c *DocumentClient) Create() *DocumentCreate {
	mutation := newDocumentMutation(c.config, OpCreate)
	return &DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Document entities.
func (c *DocumentClient) CreateBulk(builders ...*DocumentCreate) *DocumentCreateBulk {
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentClient) MapCreateBulk(slice any, setFunc func(*DocumentCreate, int)) *DocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCreateBulk{err: fmt.Errorf("calling to DocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Document.
func (c *DocumentClient) Update() *DocumentUpdate {
	mutation := newDocumentMutation(c.config, OpUpdate)
	return &DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentClient) UpdateOne(d *Document) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocument(d))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentClient) UpdateOneID(id string) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocumentID(id))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Document.
func (c *DocumentClient) Delete() *DocumentDelete {
	mutation := newDocumentMutation(c.config, OpDelete)
	return &DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentClient) DeleteOne(d *Document) *DocumentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentClient) DeleteOneID(id string) *DocumentDeleteOne {
	builder := c.Delete().Where(document.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDeleteOne{builder}
}

// Query returns a query builder for Document.
func (c *DocumentClient) Query() *DocumentQuery {
	return &DocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a Document entity by its id.
func (c *DocumentClient) Get(ctx context.Context, id string) (*Document, error) {
	return c.Query().Where(document.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentClient) GetX(ctx context.Context, id string) *Document {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEventDocuments queries the event_documents edge of a Document.
func (c *DocumentClient) QueryEventDocuments(d *Document) *EventDocumentQuery {
	query := (&EventDocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(eventdocument.Table, eventdocument.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, document.EventDocumentsTable, document.EventDocumentsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessage queries the message edge of a Document.
func (c *DocumentClient) QueryMessage(d *Document) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, document.MessageTable, document.MessagePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentClient) Hooks() []Hook {
	return c.hooks.Document
}

// Interceptors returns the client interceptors.
func (c *DocumentClient) Interceptors() []Interceptor {
	return c.inters.Document
}

func (c *DocumentClient) mutate(ctx context.Context, m *DocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Document mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id string) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id string) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id string) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id string) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Event.
func (c *EventClient) QueryUser(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.UserTable, event.UserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a Event.
func (c *EventClient) QueryMessages(e *Event) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.MessagesTable, event.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventDocuments queries the event_documents edge of a Event.
func (c *EventClient) QueryEventDocuments(e *Event) *EventDocumentQuery {
	query := (&EventDocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(eventdocument.Table, eventdocument.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.EventDocumentsTable, event.EventDocumentsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubjects queries the subjects edge of a Event.
func (c *EventClient) QuerySubjects(e *Event) *SubjectQuery {
	query := (&SubjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, event.SubjectsTable, event.SubjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipants queries the participants edge of a Event.
func (c *EventClient) QueryParticipants(e *Event) *ParticipantQuery {
	query := (&ParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(participant.Table, participant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.ParticipantsTable, event.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemoteEvent queries the remote_event edge of a Event.
func (c *EventClient) QueryRemoteEvent(e *Event) *RemoteEventQuery {
	query := (&RemoteEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(remoteevent.Table, remoteevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.RemoteEventTable, event.RemoteEventColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPhysicalEvent queries the physical_event edge of a Event.
func (c *EventClient) QueryPhysicalEvent(e *Event) *PhysicalEventQuery {
	query := (&PhysicalEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(physicalevent.Table, physicalevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.PhysicalEventTable, event.PhysicalEventColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// EventDocumentClient is a client for the EventDocument schema.
type EventDocumentClient struct {
	config
}

// NewEventDocumentClient returns a client for the EventDocument from the given config.
func NewEventDocumentClient(c config) *EventDocumentClient {
	return &EventDocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventdocument.Hooks(f(g(h())))`.
func (c *EventDocumentClient) Use(hooks ...Hook) {
	c.hooks.EventDocument = append(c.hooks.EventDocument, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventdocument.Intercept(f(g(h())))`.
func (c *EventDocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventDocument = append(c.inters.EventDocument, interceptors...)
}

// Create returns a builder for creating a EventDocument entity.
func (c *EventDocumentClient) Create() *EventDocumentCreate {
	mutation := newEventDocumentMutation(c.config, OpCreate)
	return &EventDocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventDocument entities.
func (c *EventDocumentClient) CreateBulk(builders ...*EventDocumentCreate) *EventDocumentCreateBulk {
	return &EventDocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventDocumentClient) MapCreateBulk(slice any, setFunc func(*EventDocumentCreate, int)) *EventDocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventDocumentCreateBulk{err: fmt.Errorf("calling to EventDocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventDocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventDocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventDocument.
func (c *EventDocumentClient) Update() *EventDocumentUpdate {
	mutation := newEventDocumentMutation(c.config, OpUpdate)
	return &EventDocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventDocumentClient) UpdateOne(ed *EventDocument) *EventDocumentUpdateOne {
	mutation := newEventDocumentMutation(c.config, OpUpdateOne, withEventDocument(ed))
	return &EventDocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventDocumentClient) UpdateOneID(id string) *EventDocumentUpdateOne {
	mutation := newEventDocumentMutation(c.config, OpUpdateOne, withEventDocumentID(id))
	return &EventDocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventDocument.
func (c *EventDocumentClient) Delete() *EventDocumentDelete {
	mutation := newEventDocumentMutation(c.config, OpDelete)
	return &EventDocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventDocumentClient) DeleteOne(ed *EventDocument) *EventDocumentDeleteOne {
	return c.DeleteOneID(ed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventDocumentClient) DeleteOneID(id string) *EventDocumentDeleteOne {
	builder := c.Delete().Where(eventdocument.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDocumentDeleteOne{builder}
}

// Query returns a query builder for EventDocument.
func (c *EventDocumentClient) Query() *EventDocumentQuery {
	return &EventDocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a EventDocument entity by its id.
func (c *EventDocumentClient) Get(ctx context.Context, id string) (*EventDocument, error) {
	return c.Query().Where(eventdocument.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventDocumentClient) GetX(ctx context.Context, id string) *EventDocument {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a EventDocument.
func (c *EventDocumentClient) QueryDocument(ed *EventDocument) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventdocument.Table, eventdocument.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventdocument.DocumentTable, eventdocument.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(ed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a EventDocument.
func (c *EventDocumentClient) QueryEvent(ed *EventDocument) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ed.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventdocument.Table, eventdocument.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventdocument.EventTable, eventdocument.EventColumn),
		)
		fromV = sqlgraph.Neighbors(ed.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventDocumentClient) Hooks() []Hook {
	return c.hooks.EventDocument
}

// Interceptors returns the client interceptors.
func (c *EventDocumentClient) Interceptors() []Interceptor {
	return c.inters.EventDocument
}

func (c *EventDocumentClient) mutate(ctx context.Context, m *EventDocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventDocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventDocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventDocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventDocument mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id string) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id string) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id string) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id string) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Message.
func (c *MessageClient) QueryUser(m *Message) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.UserTable, message.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Message.
func (c *MessageClient) QueryEvent(m *Message) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, message.EventTable, message.EventColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Message.
func (c *MessageClient) QueryDocuments(m *Message) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, message.DocumentsTable, message.DocumentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// ParticipantClient is a client for the Participant schema.
type ParticipantClient struct {
	config
}

// NewParticipantClient returns a client for the Participant from the given config.
func NewParticipantClient(c config) *ParticipantClient {
	return &ParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `participant.Hooks(f(g(h())))`.
func (c *ParticipantClient) Use(hooks ...Hook) {
	c.hooks.Participant = append(c.hooks.Participant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `participant.Intercept(f(g(h())))`.
func (c *ParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Participant = append(c.inters.Participant, interceptors...)
}

// Create returns a builder for creating a Participant entity.
func (c *ParticipantClient) Create() *ParticipantCreate {
	mutation := newParticipantMutation(c.config, OpCreate)
	return &ParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Participant entities.
func (c *ParticipantClient) CreateBulk(builders ...*ParticipantCreate) *ParticipantCreateBulk {
	return &ParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ParticipantClient) MapCreateBulk(slice any, setFunc func(*ParticipantCreate, int)) *ParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ParticipantCreateBulk{err: fmt.Errorf("calling to ParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Participant.
func (c *ParticipantClient) Update() *ParticipantUpdate {
	mutation := newParticipantMutation(c.config, OpUpdate)
	return &ParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ParticipantClient) UpdateOne(pa *Participant) *ParticipantUpdateOne {
	mutation := newParticipantMutation(c.config, OpUpdateOne, withParticipant(pa))
	return &ParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ParticipantClient) UpdateOneID(id string) *ParticipantUpdateOne {
	mutation := newParticipantMutation(c.config, OpUpdateOne, withParticipantID(id))
	return &ParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Participant.
func (c *ParticipantClient) Delete() *ParticipantDelete {
	mutation := newParticipantMutation(c.config, OpDelete)
	return &ParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ParticipantClient) DeleteOne(pa *Participant) *ParticipantDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ParticipantClient) DeleteOneID(id string) *ParticipantDeleteOne {
	builder := c.Delete().Where(participant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ParticipantDeleteOne{builder}
}

// Query returns a query builder for Participant.
func (c *ParticipantClient) Query() *ParticipantQuery {
	return &ParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a Participant entity by its id.
func (c *ParticipantClient) Get(ctx context.Context, id string) (*Participant, error) {
	return c.Query().Where(participant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ParticipantClient) GetX(ctx context.Context, id string) *Participant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Participant.
func (c *ParticipantClient) QueryUser(pa *Participant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(participant.Table, participant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, participant.UserTable, participant.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Participant.
func (c *ParticipantClient) QueryEvent(pa *Participant) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(participant.Table, participant.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, participant.EventTable, participant.EventColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ParticipantClient) Hooks() []Hook {
	return c.hooks.Participant
}

// Interceptors returns the client interceptors.
func (c *ParticipantClient) Interceptors() []Interceptor {
	return c.inters.Participant
}

func (c *ParticipantClient) mutate(ctx context.Context, m *ParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Participant mutation op: %q", m.Op())
	}
}

// PhysicalEventClient is a client for the PhysicalEvent schema.
type PhysicalEventClient struct {
	config
}

// NewPhysicalEventClient returns a client for the PhysicalEvent from the given config.
func NewPhysicalEventClient(c config) *PhysicalEventClient {
	return &PhysicalEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `physicalevent.Hooks(f(g(h())))`.
func (c *PhysicalEventClient) Use(hooks ...Hook) {
	c.hooks.PhysicalEvent = append(c.hooks.PhysicalEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `physicalevent.Intercept(f(g(h())))`.
func (c *PhysicalEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.PhysicalEvent = append(c.inters.PhysicalEvent, interceptors...)
}

// Create returns a builder for creating a PhysicalEvent entity.
func (c *PhysicalEventClient) Create() *PhysicalEventCreate {
	mutation := newPhysicalEventMutation(c.config, OpCreate)
	return &PhysicalEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PhysicalEvent entities.
func (c *PhysicalEventClient) CreateBulk(builders ...*PhysicalEventCreate) *PhysicalEventCreateBulk {
	return &PhysicalEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PhysicalEventClient) MapCreateBulk(slice any, setFunc func(*PhysicalEventCreate, int)) *PhysicalEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PhysicalEventCreateBulk{err: fmt.Errorf("calling to PhysicalEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PhysicalEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PhysicalEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PhysicalEvent.
func (c *PhysicalEventClient) Update() *PhysicalEventUpdate {
	mutation := newPhysicalEventMutation(c.config, OpUpdate)
	return &PhysicalEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PhysicalEventClient) UpdateOne(pe *PhysicalEvent) *PhysicalEventUpdateOne {
	mutation := newPhysicalEventMutation(c.config, OpUpdateOne, withPhysicalEvent(pe))
	return &PhysicalEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PhysicalEventClient) UpdateOneID(id string) *PhysicalEventUpdateOne {
	mutation := newPhysicalEventMutation(c.config, OpUpdateOne, withPhysicalEventID(id))
	return &PhysicalEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PhysicalEvent.
func (c *PhysicalEventClient) Delete() *PhysicalEventDelete {
	mutation := newPhysicalEventMutation(c.config, OpDelete)
	return &PhysicalEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PhysicalEventClient) DeleteOne(pe *PhysicalEvent) *PhysicalEventDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PhysicalEventClient) DeleteOneID(id string) *PhysicalEventDeleteOne {
	builder := c.Delete().Where(physicalevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PhysicalEventDeleteOne{builder}
}

// Query returns a query builder for PhysicalEvent.
func (c *PhysicalEventClient) Query() *PhysicalEventQuery {
	return &PhysicalEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePhysicalEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a PhysicalEvent entity by its id.
func (c *PhysicalEventClient) Get(ctx context.Context, id string) (*PhysicalEvent, error) {
	return c.Query().Where(physicalevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PhysicalEventClient) GetX(ctx context.Context, id string) *PhysicalEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a PhysicalEvent.
func (c *PhysicalEventClient) QueryEvent(pe *PhysicalEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(physicalevent.Table, physicalevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, physicalevent.EventTable, physicalevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PhysicalEventClient) Hooks() []Hook {
	return c.hooks.PhysicalEvent
}

// Interceptors returns the client interceptors.
func (c *PhysicalEventClient) Interceptors() []Interceptor {
	return c.inters.PhysicalEvent
}

func (c *PhysicalEventClient) mutate(ctx context.Context, m *PhysicalEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PhysicalEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PhysicalEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PhysicalEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PhysicalEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PhysicalEvent mutation op: %q", m.Op())
	}
}

// RemoteEventClient is a client for the RemoteEvent schema.
type RemoteEventClient struct {
	config
}

// NewRemoteEventClient returns a client for the RemoteEvent from the given config.
func NewRemoteEventClient(c config) *RemoteEventClient {
	return &RemoteEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `remoteevent.Hooks(f(g(h())))`.
func (c *RemoteEventClient) Use(hooks ...Hook) {
	c.hooks.RemoteEvent = append(c.hooks.RemoteEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `remoteevent.Intercept(f(g(h())))`.
func (c *RemoteEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.RemoteEvent = append(c.inters.RemoteEvent, interceptors...)
}

// Create returns a builder for creating a RemoteEvent entity.
func (c *RemoteEventClient) Create() *RemoteEventCreate {
	mutation := newRemoteEventMutation(c.config, OpCreate)
	return &RemoteEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RemoteEvent entities.
func (c *RemoteEventClient) CreateBulk(builders ...*RemoteEventCreate) *RemoteEventCreateBulk {
	return &RemoteEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RemoteEventClient) MapCreateBulk(slice any, setFunc func(*RemoteEventCreate, int)) *RemoteEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RemoteEventCreateBulk{err: fmt.Errorf("calling to RemoteEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RemoteEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RemoteEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RemoteEvent.
func (c *RemoteEventClient) Update() *RemoteEventUpdate {
	mutation := newRemoteEventMutation(c.config, OpUpdate)
	return &RemoteEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RemoteEventClient) UpdateOne(re *RemoteEvent) *RemoteEventUpdateOne {
	mutation := newRemoteEventMutation(c.config, OpUpdateOne, withRemoteEvent(re))
	return &RemoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RemoteEventClient) UpdateOneID(id string) *RemoteEventUpdateOne {
	mutation := newRemoteEventMutation(c.config, OpUpdateOne, withRemoteEventID(id))
	return &RemoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RemoteEvent.
func (c *RemoteEventClient) Delete() *RemoteEventDelete {
	mutation := newRemoteEventMutation(c.config, OpDelete)
	return &RemoteEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RemoteEventClient) DeleteOne(re *RemoteEvent) *RemoteEventDeleteOne {
	return c.DeleteOneID(re.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RemoteEventClient) DeleteOneID(id string) *RemoteEventDeleteOne {
	builder := c.Delete().Where(remoteevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RemoteEventDeleteOne{builder}
}

// Query returns a query builder for RemoteEvent.
func (c *RemoteEventClient) Query() *RemoteEventQuery {
	return &RemoteEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRemoteEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a RemoteEvent entity by its id.
func (c *RemoteEventClient) Get(ctx context.Context, id string) (*RemoteEvent, error) {
	return c.Query().Where(remoteevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RemoteEventClient) GetX(ctx context.Context, id string) *RemoteEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a RemoteEvent.
func (c *RemoteEventClient) QueryEvent(re *RemoteEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remoteevent.Table, remoteevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, remoteevent.EventTable, remoteevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RemoteEventClient) Hooks() []Hook {
	return c.hooks.RemoteEvent
}

// Interceptors returns the client interceptors.
func (c *RemoteEventClient) Interceptors() []Interceptor {
	return c.inters.RemoteEvent
}

func (c *RemoteEventClient) mutate(ctx context.Context, m *RemoteEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RemoteEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RemoteEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RemoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RemoteEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RemoteEvent mutation op: %q", m.Op())
	}
}

// ReportingClient is a client for the Reporting schema.
type ReportingClient struct {
	config
}

// NewReportingClient returns a client for the Reporting from the given config.
func NewReportingClient(c config) *ReportingClient {
	return &ReportingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reporting.Hooks(f(g(h())))`.
func (c *ReportingClient) Use(hooks ...Hook) {
	c.hooks.Reporting = append(c.hooks.Reporting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reporting.Intercept(f(g(h())))`.
func (c *ReportingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reporting = append(c.inters.Reporting, interceptors...)
}

// Create returns a builder for creating a Reporting entity.
func (c *ReportingClient) Create() *ReportingCreate {
	mutation := newReportingMutation(c.config, OpCreate)
	return &ReportingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reporting entities.
func (c *ReportingClient) CreateBulk(builders ...*ReportingCreate) *ReportingCreateBulk {
	return &ReportingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReportingClient) MapCreateBulk(slice any, setFunc func(*ReportingCreate, int)) *ReportingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReportingCreateBulk{err: fmt.Errorf("calling to ReportingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReportingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReportingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reporting.
func (c *ReportingClient) Update() *ReportingUpdate {
	mutation := newReportingMutation(c.config, OpUpdate)
	return &ReportingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReportingClient) UpdateOne(r *Reporting) *ReportingUpdateOne {
	mutation := newReportingMutation(c.config, OpUpdateOne, withReporting(r))
	return &ReportingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReportingClient) UpdateOneID(id string) *ReportingUpdateOne {
	mutation := newReportingMutation(c.config, OpUpdateOne, withReportingID(id))
	return &ReportingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reporting.
func (c *ReportingClient) Delete() *ReportingDelete {
	mutation := newReportingMutation(c.config, OpDelete)
	return &ReportingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReportingClient) DeleteOne(r *Reporting) *ReportingDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReportingClient) DeleteOneID(id string) *ReportingDeleteOne {
	builder := c.Delete().Where(reporting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReportingDeleteOne{builder}
}

// Query returns a query builder for Reporting.
func (c *ReportingClient) Query() *ReportingQuery {
	return &ReportingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReporting},
		inters: c.Interceptors(),
	}
}

// Get returns a Reporting entity by its id.
func (c *ReportingClient) Get(ctx context.Context, id string) (*Reporting, error) {
	return c.Query().Where(reporting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReportingClient) GetX(ctx context.Context, id string) *Reporting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Reporting.
func (c *ReportingClient) QueryUser(r *Reporting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reporting.Table, reporting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reporting.UserTable, reporting.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReportingClient) Hooks() []Hook {
	return c.hooks.Reporting
}

// Interceptors returns the client interceptors.
func (c *ReportingClient) Interceptors() []Interceptor {
	return c.inters.Reporting
}

func (c *ReportingClient) mutate(ctx context.Context, m *ReportingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReportingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReportingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReportingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReportingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reporting mutation op: %q", m.Op())
	}
}

// SubjectClient is a client for the Subject schema.
type SubjectClient struct {
	config
}

// NewSubjectClient returns a client for the Subject from the given config.
func NewSubjectClient(c config) *SubjectClient {
	return &SubjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subject.Hooks(f(g(h())))`.
func (c *SubjectClient) Use(hooks ...Hook) {
	c.hooks.Subject = append(c.hooks.Subject, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subject.Intercept(f(g(h())))`.
func (c *SubjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subject = append(c.inters.Subject, interceptors...)
}

// Create returns a builder for creating a Subject entity.
func (c *SubjectClient) Create() *SubjectCreate {
	mutation := newSubjectMutation(c.config, OpCreate)
	return &SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subject entities.
func (c *SubjectClient) CreateBulk(builders ...*SubjectCreate) *SubjectCreateBulk {
	return &SubjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubjectClient) MapCreateBulk(slice any, setFunc func(*SubjectCreate, int)) *SubjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubjectCreateBulk{err: fmt.Errorf("calling to SubjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subject.
func (c *SubjectClient) Update() *SubjectUpdate {
	mutation := newSubjectMutation(c.config, OpUpdate)
	return &SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectClient) UpdateOne(s *Subject) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubject(s))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectClient) UpdateOneID(id string) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubjectID(id))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subject.
func (c *SubjectClient) Delete() *SubjectDelete {
	mutation := newSubjectMutation(c.config, OpDelete)
	return &SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubjectClient) DeleteOne(s *Subject) *SubjectDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubjectClient) DeleteOneID(id string) *SubjectDeleteOne {
	builder := c.Delete().Where(subject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectDeleteOne{builder}
}

// Query returns a query builder for Subject.
func (c *SubjectClient) Query() *SubjectQuery {
	return &SubjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubject},
		inters: c.Interceptors(),
	}
}

// Get returns a Subject entity by its id.
func (c *SubjectClient) Get(ctx context.Context, id string) (*Subject, error) {
	return c.Query().Where(subject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectClient) GetX(ctx context.Context, id string) *Subject {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Subject.
func (c *SubjectClient) QueryUsers(s *Subject) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subject.UsersTable, subject.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Subject.
func (c *SubjectClient) QueryEvents(s *Subject) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subject.EventsTable, subject.EventsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectClient) Hooks() []Hook {
	return c.hooks.Subject
}

// Interceptors returns the client interceptors.
func (c *SubjectClient) Interceptors() []Interceptor {
	return c.inters.Subject
}

func (c *SubjectClient) mutate(ctx context.Context, m *SubjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subject mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBadges queries the badges edge of a User.
func (c *UserClient) QueryBadges(u *User) *BadgeQuery {
	query := (&BadgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(badge.Table, badge.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.BadgesTable, user.BadgesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubjects queries the subjects edge of a User.
func (c *UserClient) QuerySubjects(u *User) *SubjectQuery {
	query := (&SubjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.SubjectsTable, user.SubjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a User.
func (c *UserClient) QueryEvents(u *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EventsTable, user.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a User.
func (c *UserClient) QueryMessages(u *User) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MessagesTable, user.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a User.
func (c *UserClient) QueryReports(u *User) *ReportingQuery {
	query := (&ReportingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reporting.Table, reporting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReportsTable, user.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipants queries the participants edge of a User.
func (c *UserClient) QueryParticipants(u *User) *ParticipantQuery {
	query := (&ParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(participant.Table, participant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ParticipantsTable, user.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Badge, Document, Event, EventDocument, Message, Participant, PhysicalEvent,
		RemoteEvent, Reporting, Subject, User []ent.Hook
	}
	inters struct {
		Badge, Document, Event, EventDocument, Message, Participant, PhysicalEvent,
		RemoteEvent, Reporting, Subject, User []ent.Interceptor
	}
)
